# 객체지향의 오해와 사실

#  협력하는 객체들

# 잘못된 오해

- 잘못된 사실

  - "객체지향은 실세계를 직관적으로 모방하여 소프트웨어 내부로 옮겨오는 작업이다"
  - 객체란 현실세계에 존재하는 사물에 대한 추상화

  

- **객체지향의 본질적 목표**

  - 실세계를 모방하는 것이 아니라 
  - 신세계를 창조하는 것

  

- 위 잘못된 사실은 객체지향을 이해하는 초반에는 도움이 된다.(그러나 본질은 아니다.)

  - 다음 개념(연결완전성=캡슐화 + 자율성)을 설명하는데 도움을 준다.
  - 캡슐화(상태와 행위를 캡슐화) 
  - 자율성
  - 협력(메세지를 주고 받으며 공동의 목표를 달성해 나가는 공동체)

# 1.2 객체지향에 대한 오해로 객체지향 이해하기

## 카페에서 커피를 주문하는 과정(역할, 책임, 협력)

- **객체 구성**
  - 손님
  - 사장
  - 바리스타

- **위 세명의 '협력'관계가 존재함**
  - 이유는 각자가 역할이 존재함
  - 각자 자신이 맡은 역할에 **'책임'**을 다함
- **'역할' (책임을 부여받음)**
  - 손님: 커피를 주문
  - 사장: 주문을 받음
  - 바리스타: 커피를 만듬



## 1.2.2. 협력, 역할, 책임 특징

**협력** 

- 역할을 수행하기 위해 외부와 소통하는 과정

- 요청과 응답 과정을 **메세지**를 주고 받으면 수행

**역할**

- 다른 객체로 역할을 수행할 수 있음
  - 손님입장에서 커피만 마실 수 있으면 어떤 사장이나 바리스타도 상관없음
- 즉, 역할은 다른 객체로 대체가능함
- 한 객체가 두 역할을 동시에 맡을 수 도 있다.

**책임**

- 책임을 수행하는 방법은 역할을 맡은 객체가 자율적으로 선택할 수 있다.
  - 객체마다 수행하는 방법이 다르다 (다형성)



## 1.2.3 메소드와 자율성p.35

- 객체의 메소드가 실행되기 위해서는 외부객체로부터 메세지를 받아야 한다.

- 메세지 수신한 객체는 메세지에 따라 실행할 메소드를 선택할 수 있다(자율성이 있음)
  - 특정 메세지에 특정 메소드가 매칭되어 있음.



## 1.2.4 객체지향의 중심개념

- 클래스가 중심이 아니다.
- 클래스는 객체의 협력관계를 코드로 옮겨놓은 도구에 불과함
- 중심개념은 "적절한 책임을 수행하는 역할간 유연하고 견고한 협력관계를 구축하는 객체 공동체"이다.

객체의 **상태**

- 프로퍼티 + 프로퍼티값 으로 구성
- 프로퍼티(정적)
- 프로퍼티값(동적)

객체의 **자율성**

- 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 직접적으로 변경할 수 없다.
- 객체는 스스로 자신의 상태를 책임져야 한다.
- 단, 외부의 객체에 의해 간접적으로 객체의 상태를 변경하거나 조회할 수 있다(setter/getter)
  - 이때 사용되는 것이 객체의 자발적인 **행동**이다.
  - 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장한다.
  - 이것이 객체의 자율성을 유지하는 방법이다.

객체의 **행동**

- 엘리스의 키가 작아진 이유는 앨리스가 음료를 마셨기 때문
- 엘리스의 위치이동이 일어난 이유는 엘리스가 문을 통과했기 때문
- 엘리스의 행동이 엘리스의 상태를 변경시킴
- 즉, 객체가 취하는 행동으로 객체의 상태를 변경시킴

- **행동의 결과는 객체의 상태에 의존적이고**
- **행동의 결과는 객체의 상태를 변화시킨다**.

- 엘리스가 음료를 마시는 행위(1)
  - 엘리스의 키를 작아지게 만듬
  - 동시에, 음료의 양을 줄게만듬
- 해석
  - 객체자신의 상태 변경
  - 협력하는 다른 객체(음료)에게 메세지 전송



## 1.2.3. 상태의 캡슐화 (상태를 노출시키지 않는다)

-  현실세계

  - 앨리스는 음료수를 마시는 능동적인 존재
  - 음료는 아무것도 할 수 없는 수동적인 존재

- 객체지향

  - 예)

    - 앨리스, 음료 모두 자율적인 존재
    - 앨리스 객체의 키를 작게 만드는 주체는 앨리스 자신
    - 음료 객체의 양을 작게 만드는 주체는 음료 자신 
    - 따라서 앨리스가 음료 객체의 양을 변경시킬 수 없음(음료의 자율성 때문에)
    - 앨리스는 음료에게 양을 줄이도록 메시지 전달할 뿐!
    - 엘리스는 메시지를 전달 할 뿐 음료의 상태변화를 알 수 없다(캡슐화 덕분)



## 캡슐화

외부에 자신의 **상태**를 **노출하지 않는다.**

- 메세지를 받았을 때)
  - 상태를 변경할 지 말지를 객체가 자율적으로 판단
  - 변경하기로 결정하면 **행동**을 취해서 상태를 변경한다.
- 메세지를 보낼 때)
  - 외부객체에게 자신이 원하는 요구사항을 요청할 때 메세지를 본낸다.
  - 메세지를 보내는 방법으로 **행동**이 있다.
  - 외부에 노출하는 건 협력을 위한 행동뿐이다.(메세지를 보내는 수단인 행동)
- 정리
  - 캡슐화는 속성을 여럿 모아놓고 그 경계를 행동으로 감싸놓는 개념
  - 외부로 부터 속성에 직접접근을 방지
  - 외부가 속성에 간접접근하도록 허용
    - 외부객체에서 객체로 메세지를 보내고 
    - 객체가 자율적으로 판단하에 주체적으로 메소드(행동)호출



- 객체의 행동을 유발하는 건 외부로 부터 수신된 메시지

- 그러나, 상태를 변경할지 여부(행동을 취할지)는 객체 스스로 결정한다.(자율성)

- 메세지를 보내는 객체는 단지 자신의 요구사항을 담아 보낼 뿐

  - 메세지를 받는 객체의 속성변화에는 관심없음

  

## 1.2.5 행동이 상태를 결정한다.

- 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 안좋다

  1. 행동을 먼저 정의해야 모든 상태를 빠짐없이 캡슐화할 수 있다.

     상태먼저 생각하다 보면 캡슐화할 상태를 빼먹을 수 있다.

  2. 상태를 먼저 고려하면 행위에 대해 깊게 생각할 수 없다.

     협력을 하기 위해서 행위가 잘 정의되야 한다. 

     행위를 통해 메세지를 발송하고

     메세지를 받고 행위를 하기 때문이다.

  3. 객체의 재사용성이 저하된다.

     재사용될려면 다양한 협력에 참여할 수 있어야 한다.

     행위가 잘 정의되야 협력의 범위중 필요한 부분에 재사용될 수 있다.

- 객체의 **행동**

  - 겍체가 협력에 참여할 수 있게 해주는 유일한 방법
  - 객체가 협력에 적합한지는 객체의 행동을 보고 판단

  - 행동을 잘 정의한다면 행동이 어떤 상태에 의존적인지를 파악하므로서 필요한 상태를 정의할 수 있음
  - 행동은 협력안에서의 객체가 맡은 역할인 동시에 책임이다.(행동 = 책임)
  - 행동이 상태를 결정한다



## 1.2.6 은유와 객체

- 잘못된 사실
  - 객체지향은 현실 세계의 모방, 추상화
  - 객체지향은 현실 세계의 핵심을 추려놓은것
- 올바른 사실
  - **객체지향의 세계로 들어오면 실제세계의 수동적인 존재들도 능동적인 주체자가 된다.**
  - 현실세계에서 갖출 수 없는 추가적인 능력을 갖게됨
  - 의인화 예)
    - 전화기 스스로 전화검
    - 계좌객체 스스로 송금함
    - 상품스스로 판매금액을 종이에 기입함
  - 객체지향의 세계는 현실세계에 대한 은유다.
- 객체지향 세계의 객체를 이해하기 위해 현실세계의 객체의 개념을 그대로 대입하면 그나마 객체지향의 세계를 이해하는데 도움을 주긴함

# 2. 타입과 추상화

# 추상화

-  몰라도 되는 정보는 무시

- 쉽고, 단순하며

- 목적에 부합하는

- 즉, 추상화를 함

  

**현실의 복잡성 정도**

- 너무 복잡해서 이해하기 힘들 정도
- 이해하고 싶으면 어떻게? 단순화하라!
- 단, 단순화를 하더라도 목적에 맞게 본질은 드러나게 해라!
- 목적이 잘못되면 추상화를 해도 대상을 이해할 수 없음...ㅠㅠ

**추상화 방법**

- 여러 현실의 현상들에서 갖는 공통점을 추출해냄
- 불필요한 세부사항은 제거한다.

# 2.2. 개념

**객체를 그룹화할 수 있는 아이디어나 관념**

- 객체지향에는 구체적이고 실제적인 객체가 존재함.
- 수 많은 객체들 개별을 파악하기란 인간의 인지능력으로 부족함....
- 따라서, 공통적인 특성을 갖는 객체들을 그룹화한다.
- 개념은 특정객제가 어떤 그룹에 속할지 기준이 된다. 결정을 한다.

**개념을 구성하는 요소 (외연, 내연, 심볼)**

- 외연
  - 정원사, 병사, 신하, 왕자와 공주,,,,
- 내연
  - 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물
- 심볼
  - 트럼프



- 외연
  - 개념에 속하는 모든 인스턴스들
- 내연
  - 개념의 명세
- 심볼
  - 개념의 이름

# 2.3. 인스턴스

**객체에 개념을 적용해서 그룹안에 분류를 하게되면 그 그룹의 일원이 됨. 이때 이 객체를 그 개념의 인스턴스라고 한다**'

# 2.4. 분류

- 객체에 특정 개념 기준삼아 개념을 적용하는 일
- 객체를 특정 그룹의 멤버로 나누는 일
- 분류를 잘해야 객체지향의 품질이 좋다
- 분류를 잘해야 추상화를 잘한것이다.
- 좀 더 객체지향 세계를 잘 파악(인지)할 수 있다.
- 추상화를 위한 도구



# 2.5. 타입 (=개념)

**데이터 타입**

- 데이터에 대한 분류 --> 어떤 종류의 연산이 해당 데이터에 대해 수행될지 결정
- 중요한 특징
  1. 객체가 어떤 타입에 속할지 결정하는 요인 : 객체가 수행하는 행동
     - 객체들이 동일한 행동을 한다면 그 객체들은 동일한 타입으로 분류될 수 있음.
     - 동일한 행동이나 방식은 객체마다 자율성으로 인해 다를 수 있음
  2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.
     - 객체마다 자율설을 갖고 있고 가장 효과적으로 행동을 수행할 수만 있다면 
     - 객체 내부의 **상태**를 어떤 방식으로 표현하든 상관없다



## 객체지향의 중요원칙(위 데이터타입의 특징으로 부터 도출가능)

책임주도 설계

1. **행동이 우선이다.**

   - 동일행동 = 동일 데이터타입

   - 동일행동 = 동일책임

   - 동일책임의 의미

     - 동일한 메시지 수신을 의미함

   - 동일행동 = 동일한 책임을 지님 = 동일한 메세지를 수신할 수 있음

   - 메세지 = 행동

   - 객체의 다형성

     - 동일한 메시지를 수신하나 객체마다의 메세지를 처리하는 방식은 다를 수 있다.

     - 전적으로 객체에게 맡긴다.(자율성)

       

2. **객체의 타입은 객체의 내부 표현(상태)과는 아무런 상관이 없다.**

   - **객체의 내부 표현이 다르더라도(= 상태가 다르더라도) 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다.**
   - **행동만이 중요함.**
     - 외부에 데이터를 보여줄 필요없음
     - 외부에 데이터를 감춰야함.
     - 객체가 지닌 데이터는 객체를 분류하는 기준이 아님
   - **외부에 행동만을 제공**



## 타입의 계층 (일반화 / 특수화 ) 

- 슈퍼타입 - 일반화
  - 범위가 넓음, 특징이 적음(이유. 공통적인 특징만 있어서), 유연함
- 서브타입 - 특수화
  - 범위가 좁음, 특징이 많음(이유. 개별적인 특징이 추가돼서), 유연하지 못함

## 추상화

객체 --> 타입(서브타입) --> 슈터타입



## 타입의 목적

- 왜 추상화를 할까?
- 답. 이해하고 싶어서
- 객체는 시간에 따라 동적으로 상태가 변경된다. 객체의 복잡성을 이해하기 어렵다.
- 시간에 무관한 정적인 상태를 정의
- 타입 = 추상화

- 클래스
  - 타입을 구현한 보편적 방법



# 역할, 책임, 협력

## 객체설계

- 객체의 행동은 문맥에 따라 다르다.
- 즉, 협력을 어떻게 할 것인가에 따라 다르다.
- 따라서 조화롭게 협력하는 객체를 설계하기 위해서는 객체의 특징을 먼저 볼것이 아니라
- 어떻게 협력할 것인가를 먼저 고민한다.

**어떤 협력에 참여하는가** 

- 협력에 따라 객체의 행동이 결정됨
- 객체의 행동이 결정되면 객체의 상태를 결정함

**협력 -> 행동(책임) -> 상태 순으로 결정**



## 협력

한 객체가 다른 객체에게 도움을 요청

- 자신이 해결할 수 없는 문제는 다른 객체에게 도움을 요청한다.
- 요청을 받은 다른 객체는 문제를 해결하는데 필요한 지식을 갖고 있음
- 또는 문제를 해결할 수 있는 다른 객체의 존재를 알고있음

**다른 객체로 부터 요청을 받을 수 있는 이유**

- 그 요청에 대해 적절한 방식으로 응답하는데 필요한 지식과 행동방식을 가지고 있기 때문
- 필요한 지식 : 상태
- 행동방식: 행동

## 책임(행위의 집합, 공용인터페이스의 집합)

한 객체가 어떤 요청에 대해 대답해 줄 수 있음, 적절한 행동을 할 의무가 있을 경우 해당객체가 책임을 가진다고 말한다.

- **책임의 분류**

  - 아는 것 (외부에 제공할 정보)인터페이스
    - 정보, 관련 객체에 대해 아는 것
    - "하얀 토끼는 목격자가 모자장수라는 사실을 알고 있음"
    - "모자장수는 사실을 알고 있음"
  - 하는 것 (외부에 제공할 서비스)인터페이스
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
    - 다른 객체를 생성하는 것
    - 계산을 스스로 하는 것
    - "왕은 다른 객체들의 활동을 제어하고 제어함"
    - "하얀토끼는 목격자에게 증언하도록 행동을 시작시킴"
    - "입장하라는 요청에 대해 스스로 증인석에 입장해야하는 모자장수"
    - "증언을 해야하는 모자장수"

  

- **메세지: 책임을 수행하도록 유도하는 수단**

  - 두 객체가 협력을 할 수 있는 방법
  - 요청을 보내는 행위는 메세지를 전달하는 행위
  - 한 객체는 다른 객체에게 책임을 수행하라고 메세지를 통해 요청을 보낸다.
  - 메세지를 수신한 객체는 책임을 수행한다.
    - 외부에 행동을 제공함
  - (p.118 아래서 두번째 문단 이해못함...)
    - "한가지 주의할점 책임과 메시지의 수준이 같지않음"
    - "책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것"
    - "책임을 결정한 후 실제로 협력을 정제하면서 이를 메세지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다."
    - 예) 증인으로서 책임을 다하려면 여러종류의 메세지를 처리할 줄 알아야함

  

- **책임의 설계**

  - 초반) 객체가 어떤 책임을 가지고 어떤 방식으로 서로 협력해야하는지는 개요만 알고있으면 충분
  - 중반) 책임과 협력의 구조가 자리 잡음
  - 후반) 책임을 구체적으로 구현
  - **측, 객체가 어떤 책임을 수행해야하고 어떤 객체로 부터 메세지를 수신할 것인지를 결정하는 것이 시작임**

## 역할(협력을 추상화 할 수 있는 도구)

- 책임은 좀 구체적인 개념이다. 
- 증인석에 앉은 엘리스와 모자장수는 모두 증언을 해야할 책임을 갖는다.
- 그런 둘을 그냥 **증인**이라고 할 수 있다.(추상화)
- 추상화를 하면 역할 자리를 다양한 객체로 **대체가능**하다.
- 증인석을 엘리스나 모자장수로 대체가능하다.
- **대체가능한 조건**
  - 요청받은 메세지를 처리할 수 있을 때
  - "판결요청에 대해 판결을 내릴 수 있는지"
  - "증언하라는 요청에 대해 증언 할 수 있는지"
- 구체적인 협력관계
  - 왕-하얀토끼-모자장수
  - 왕-하얀토끼-요리사
  - 여와-하얀토끼-앨리스
- 추상적인 역할
  - 판사 - 하얀토끼 - 증인
  - 협력을 다양한 문맥에서 재사용할 수 있다
  - 역할의 **대체가능성**덕분

## 역할의 대체가능성

- 한 역할에 대해

  - 요청메세지를 처리 할 수 있는 객체면 어떤 것이든 대체가능함
  - 역할로써 수행하는 모든 책임을 처리할 수 있어야 대체가능함

- 한 객체에 대해

  - 여러 역할을 갖을 수 있음
  - 엘리스의 경우 '증인', '주인공', '딸', '외부인' 등등
  - 각 역할이 수행하는 책임이 다양하기에 객체가 수행하는 책임은 생각보다 엄청 많다...

- **타입 과 역할 차이**

  두 개념모두 객체의 추상화이긴 하나....역할이 더 추상적임

  - 타입
    - 구체적인 개념, 특수화
    - 트럼펫, 인간
  - **역할(협력을 이해하는데 필요한 도구)**
    - 일반적인 개념, 일반화
    - 증인, 판사



## 좋은 객체를 설계하기 위한 시작은?

- 흔한 오류
  - 객체의 목적은 데이터를 저장하기 위해?
    - 객체가 행위를 수행하는 데 필요한 재료가 데이터(상태)일 뿐이다.
    - 행위를 수행하며 책임을 다하고 협력에 참여하기 위해서 객체는 존재한다.
    - 행동 = 책임
  - 객체지향이 클래스간의 관계를 표현하는 정적인 측면에 중점을 둔다?
    - 협력에 참여하는 동적인 객체가 중점
    - 클래스는 단지 시스템에 필요한 객체를 생성하기 위한 프로그래밍 언어가 제공하는 구현 메커니즘일 뿐
    - 클래스가 협력안에서 어떤 역할을 맡았고 어떤 책임을 수행할 것인지 결정하는 것이 중요
- 위 흔한 오류가 발생한 이유
  - 객체를 협력안에서 바라보지 않고 따로 떼어내어 독립적으로 바라보기 때문

- **시작은 "명확한 협력 설계"**
  - 객체간에 어떤 메세지를 보내고 어떤 순서로 요청응답흐름을 정할지가 우선
  - 위 흐름이 정해지면 자연스럽게 객체에 책임을 부여할 수 있음
- 책임을 부여받은 객체
  - 객체의 책임 = 외부에 제공할 행동
  - 행동에 필요한 상태(데이터)를 결정
- 책임(행동)과 데이터(상태)가 결정된 객체들
  - 이후에는 클래스를 설계한다 (추상화)
  - 클래스의 설계는 협력과 책임이 결정된 후에 정하는 것!
- 객체지향
  - 올바른 객체에 올바른 책임을 할당하는 것
  - 충분히 자율적인 동시에 충분히 협력적인 객체
- 객체지향 애플리케이션
  - 협력이라는 문맥안에 객체를 생각하는 것
- 협력 -> 책임(행동) -> 상태



## 설계 기법

1. 책임 주도설계
2. 디자인패턴
   - 협력, 역할, 책임의 템플릿
   - 
3. 테스트주도개발
   - 설계를 위한 기법
   - 테스트가 목적이 아님
   - 테스트를 통과해 나가기 위해 구체적인 코드를 작성해 나가며 협력, 역할, 책임을 식별하고 피드백하는 것

# 책임과 메세지 (객체지향의 강점)

- 명확한 책임을 부여받은 객체들로 구성된 협력이 짱짱
- 명확한 책임
  - 충분히 자율적인 책임
  - 너무 추상적이지도 않은 책임
  - 자율성을 훼손하지 않는 책임(적당히 추상적인 책임)
    - 자율적으로 메세지를 수행할 수 있다.
    - 메세지를 처리만 할 수 있다면 외부객체 입장에서는 메세지를 받은 객체가 어떤 방법으로 수행하는지는 중요하지 않다.
- 외부객체는 "무엇" 을 해주길 바라지 "어떻게" 해주길 바라진 않는다.
  - '증언하라'
  - '목격했던 장면을 떠올리면서 증언하라' -> 자율성 침해
  - '말로 간결하게 표현하는 방식으로 증언하라' -> 자율성 침해
- 메세지를 받은 객체는 메서드를 수행한다.
- 















